`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: UCAS
// Engineer: Astron-fjh
// 
// Create Date: 2025/02/14 00:51:03
// Design Name: Input Data Reordering Module
// Module Name: in_resort
// Project Name: fft_pipeline_multimode
// Target Devices: 
// Tool Versions: 
// Description: 
//   This module performs the input data reordering (bit reversal) for FFT/IFFT operations. 
//   It handles the reordering of the input data according to the FFT/IFFT point count (N), 
//   and supports both FFT and IFFT operations based on the `inv` signal. 
//   The module takes in complex input data in 16-bit signed fixed-point format, 
//   and outputs the reordered data, with the proper address (`addr_resort`) and real/imaginary components.
//   When `sop_in` is high, it triggers the start of the reordering process. 
//   The module also generates the necessary control signals such as `wr_en` (write enable) 
//   and `resort_complete` (indicating the completion of the reordering process).
//
//   The reordering is performed based on the bit-reversed address, which is generated by the 
//   `fliplr` function, and can handle different sizes of FFT (e.g., 64, 128, 256, 512).
//
// Dependencies: 
//   None
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module in_resort(
// ============== 时钟信号 ===============
    input  wire               clk,
    input  wire               rst_n,

// ============== 输入信号 ===============
    input  wire         [9:0] N,        // FFT/IFFT 点数     
    input  wire               inv,      // 0 表示FFT运算，1 表示IFFT运算
    input  wire               sop_in,   // 每组输入数据第一个有效数据指示，高电平有效
    input  wire signed [15:0] x_re,     // 输入数据实部，二进制补码定点格式
    input  wire signed [15:0] x_im,     // 输入数据虚部，二进制补码定点格式

// ============== 输出信号 ===============
    output reg                wr_en,
    output reg                resort_complete,
    output reg          [8:0] addr_resort,      // 重排后地址
    output reg  signed [15:0] x_re_resorted,    // 重排后的输入数据实部
    output reg  signed [15:0] x_im_resorted     // 重排后的输入数据虚部
    );

    reg  [8:0] cnt;
    reg        resort_start;    // 开始输入重新排序

    // 输入延迟一个周期
    reg signed [15:0] x_re_r, x_im_r;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            x_re_r <= 16'd0;
            x_im_r <= 16'd0;
        end else begin
            x_re_r <= x_re;
            x_im_r <= x_im;
        end
    end

    always@(posedge clk or negedge rst_n) begin
        if (!rst_n)
            resort_start <= 1'b0;
        else if (sop_in == 1)
            resort_start <= 1'b1;
        else if (cnt == N-1)
            resort_start <= 1'b0;
        else
            resort_start <= resort_start;
    end

    always@(posedge clk or negedge rst_n) begin
        if (!rst_n)
            cnt <= 0;
        else if (resort_start == 1)
            cnt <= cnt + 1;
        else
            cnt <= 0;
    end

    always@(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            x_re_resorted <= 16'd0;
            x_im_resorted <= 16'd0;
            addr_resort   <= 9'd0;
            wr_en <= 1'd0;
        end else if (resort_start == 1) begin
            x_re_resorted <= x_re_r;
            x_im_resorted <= (inv == 0) ? x_im_r : (-x_im_r);
            addr_resort   <= fliplr(cnt, N);
            wr_en <= 1'd1;
        end else begin
            x_re_resorted <= 16'd0;
            x_im_resorted <= 16'd0;
            addr_resort   <= 9'd0;
            wr_en <= 1'd0;
        end
    end

    always@(posedge clk or negedge rst_n) begin
        if (!rst_n)
            resort_complete <= 1'b0;
        else if (cnt == N-1)
            resort_complete <= 1'b1;
        else
            resort_complete <= 1'b0;
    end

    function [8:0] fliplr;
        input [8:0] bin;
        input [9:0] N;

        case(N)
            10'd64:  fliplr = {bin[8:6],bin[0],bin[1],bin[2],bin[3],bin[4],bin[5]};
            10'd128: fliplr = {bin[8:7],bin[0],bin[1],bin[2],bin[3],bin[4],bin[5],bin[6]};
            10'd256: fliplr = {bin[8],bin[0],bin[1],bin[2],bin[3],bin[4],bin[5],bin[6],bin[7]};
            10'd512: fliplr = {bin[0],bin[1],bin[2],bin[3],bin[4],bin[5],bin[6],bin[7],bin[8]};
            default: fliplr = {bin[0],bin[1],bin[2],bin[3],bin[4],bin[5],bin[6],bin[7],bin[8]};
        endcase
    endfunction    

endmodule
